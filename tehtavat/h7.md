# a.) Hello world kolmella kielellä
## C
- Oma lempi ohjelmointi kieli, simppelyyttä arvostaa

- "Hello.c" lähdekoodi:
```
    #include <stdio.h>
    int main(void){
        printf("Hello World!")
        return 0;
    }
```

- Käännetään ohjelma
- $ clang hello.c -o hello

- Suoritetaan ohjelma
- $ ./hello.c
- Hello World!

- Innostuin hieman liikaa ja tein vielä uudestaan ilman stdlibiä...
- Kryptinen, mutta kutsuu siis x86_64 linuxin kerneliä suoraan ja ei käytä mitään kirjastoja
- Kirjoitettu ATT assembly syntaxilla niin on himena tekninen lukea jos ei ole enne nähnyt tällaista

- Miksi ihmeessä? Koska voin ja tietokone viirukset käyttävät tätä taktiikkaa (shellcodena itseasiassa ja kryptattuna) etteivät kutsu suoraan systeemin funktioita, koska monesti antiviirukset ja debuggerit tekevät näihin funktioihin "Hookkeja" (trampoline hook), jotka voivat katsoa kuka kutsuu sitä funktiota ja flagata ne jos näyttää epäilyttävältä. Myös jos joku ohjelma kutsuu suoraan syscall:ia niin se on automaattinen flagi, koska se on epäilyttävää juuri edeltävän syyn takia.

- "sc64.c" lähdekoodi:
```
    typedef unsigned long long uint64_t;
    void _scwrite(const char* msg, uint64_t len){
        asm volatile(
            "mov $1, %%rax\n\t"
            "mov $1, %%rdi\n\t"
            "mov %0, %%rsi\n\t"
            "mov %1, %%rdx\n\t"
            "syscall"
            :
            : "r"(msg), "r"(len)
            : "%rax", "%rdi", "%rsi", "%rdx"
        );
    }
    __attribute__((noreturn)) void _scexit(uint64_t code) {
        asm volatile(
            "mov $60, %%rax\n\t"
            "mov %0, %%rdi\n\t"
            "syscall"
            :
            : "r"(code)
            : "%rax", "%rdi"
        );
        __builtin_unreachable();
    }

    void _start(){
        const char* msg = "Hello, World!\n";
        _scwrite(msg, 14);
        _scexit(0);
    }
```
- Tämän saa compilattua clangilla seuraavalla komennolla:
- $ clang -nostdlib -static -o hello64 sc_64.c


## Intel x86 assembly
- Noni kiinnostavempaa
- Platformi on linux debian "elf32"
- Käytetään intelin syntaxia eli "nasm" syntaxia

- "hello.asm" lähdekoodi:
```
    section .data
        msg db 'Hello world!', 0
        len equ $ -msg
    section .text
    global _start
        _start:
        mov edx, len
        mov ecx, msg
        mov ebx, 1

        mov eax, 4      ; Syscall write
        int 0x80

        mov eax, 1      ; Syscall exit
        int 0x80
```
- Suoritus ja compilaatio

- Tehdään objekti tiedosto
- $ nasm -f elf32 -o hello.o hello.asm

- Linkataan objekti tiedosto
- $ ld -m elf_i386 -o hello hello.o

- Suoritus
- $ ./hello
- Hello world!

## Python 3
- Joo joo on skriptaus kieli, mutta tehdään silti tällä!
- Joskus simppeli on hyväksi

- "hello.py" lähdekoodi:

    print("Hello world!")

- Suoritus
- $ python3 hello.py
- Hello world!

# b.) Lähteet
- Huomasin, että ihan teron oma sivu https://terokarvinen.com/linux-palvelimet/ oli unohtunut monista. Kävin lisäämässä.

# c.) Linuxiin uusi komento
- Ei ollut hajuakaan miten tää tehään, joten google laitoin googlen laulamaan
- Löytyi lähde stackexchange:sta (linkki lähteissä)
- Siellä ohjeistettiin: /usr/bin
- Kävin katsomassa ja -ls komennolla ja sieltähän löytyi kaikki tutut ohjelmat
- Lisäsin tänne uuden komennon suoraan Johannan package update notifier scriptin mukaan (aika raaka kopiointi)
```
    #!/bin/bash

    sudo apt-get update -qq
    updates=$(sudo apt-get --just-print upgrade | grep "^Inst")

    if [ -n "$updates" ]; then
            echo "Updates available"
            echo "$updates"
    else
            echo "Up to date"
    fi
```
- Tallesin tämän /usr/bin hakemistoon
- Vaihdoin myös oikeudet komennoilla:
- $ chown joona checkupdates
- $ chmod +x checkupdates

- Nyt sen voi kokeilla kirjoittamalla
- $ checkupdates
No updates

- Jee hienoa toimii..

# d.) Vanha arvioitava labra sovelletusti!
- Päätin tehdä h3 wello web server harjoituksen -> e.) tee validi HTML5 sivu

## a.) Päätin tehdä webbi palvelun uudestaan, mutta tällä kertaa
- Päätin etten käytä apache2 vaan kirjoitan itse windowsille webbi palvelimen C kielellä.
- Tässä linkki koodiini mitä käytin uudestaan:
- https://github.com/jypiter112/c-http
- https://github.com/jypiter112/c-http/blob/main/framework.h

- On siis todella epäturvallinen sivu, mutta oli mukava kerrata miten GET requestit ja HTTP protokolla toimii.
- Tein tän myös jostain syystää omilla "classeilla" vaikka C:ssä ei ole classeeja, ihan vain harjoitus mielessä

Tältä näyttää oma Server "class" (struct)
```
    struct Server{
        int isOnline;
        int recvLoop;
        SOCKET server;
        SOCKET client;
        char request[256];
        char path[256];
    } Server; 
    struct Server* pserver = &Server;
```
- Mutta toimii ja jakaa http tiedostoja (raakana) webbipalvelimellie ja se osaa lukea ne
- Ainoat haasteet tässä oli
- Muistin managointi C:kielessä
- Request koko...
- Headerin rakentaminen, sillä modernit webbi palvelut eivät suostu lukemaan tiedostoa jos siinä ei ole text/html headeriä.

# Lähteet
- Linux syscallit:
- https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit
- Komentojen sijainti
- https://unix.stackexchange.com/questions/84686/how-to-create-custom-commands-in-unix-linux
- Johanna Heinosen scripti
- https://github.com/johannaheinonen/johanna-test-repo/blob/main/linux-01102025.md
- WinApi, winsock2, jne
https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket
- Stackoverflow, tottakai
https://stackoverflow.com/questions
